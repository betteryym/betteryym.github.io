# 线程池优化

## 简单介绍

线程池是一种管理和复用线程的机制，能显著提高程序性能和系统响应速度。线程池主要思想是预先创建一定数量的线程，当有任务需要执行时，从池中获取可用线程执行任务，任务完成后线程不会被销毁，而是返回线程池中等待下一个任务。

主要优势：

1. 减少了创建、销毁线程的开销：创建和销毁线程操作相对耗时，复用已有线程能避免频繁的系统调用
2. 提高系统资源利用率：通过合理控制线程数量，避免过多线程竞争系统资源，能提高CPU、内存等资源的利用率
3. 提高系统响应性：能够快速响应并发任务，避免因创建线程的延迟导致任务处理延迟

## 核心参数及执行过程

### 核心参数

以`JAVA`中的`ThreadPoolExecutor`为例（其他编程语言类似）

- corePoolSize：线程池中核心线程的数量。提交一个新任务时，如果当前线程中的线程数少于corePoolSize，会创建新线程。即使当前有空闲的非核心线程可以使用，也会创建新线程，直到数量达到corePoolSize
- maximumPoolSize：线程池中最大的线程数量。包含核心线程和非核心线程，即在任务队列已满的情况下，可以创建的最大线程数。当线程数量超过该值时，会执行配置的拒绝策略。
- keepAliveTime：线程存活时间。当线程池中的线程数量大于corePoolSize时，多出来的那部分空闲线程最大能存活的时间，超过该时间，线程就会被回收，直到线程数等于corePoolSize
- Unit：线程存活时间的单位
- workQueue：任务队列的实现，用于存储已经提交但没有执行的任务。线程池根据任务队列的策略来进行等待任务的调度。常见队列：
  - ArrayBlockingQueue
  - LinkedBlockingQueue
  - PriorityBlockingQueue
- 拒绝策略：



### 执行过程







## 调优方法

一、线程数量的确定

考虑CPU核心数：线程数量通常与CPU核心数相关，计算密集型任务，线程数量可以设置为CPU核心数或CPU核心数+1，从而充分利用CPU资源

任务类型：IO密集型任务，由于线程在等待IO操作时会处于阻塞状态，线程数量可以适当增加，一般可以设置为2*CPU核心数

系统资源：需要考虑系统内存、网络带宽等资源限制，避免创建过多线程导致系统资源不足

二、任务队列的选择

无界队列：如果任务提交速度过快，可能会导致内存溢出

有界队列：队列满时，需要根据拒绝策略来处理新提交的任务

三、拒绝策略的设置

- Abort: 抛出异常，阻止新任务提交
- CallerRuns：将任务回退到调用者线程执行
- DiscardOldest：丢弃队列中最旧未处理任务，将新任务加入队列
- Discard：直接丢弃新提交的任务，不做其他处理

四、线程池参数的动态调整

需要根据系统负载和任务类型的变化，动态调整线程池的核心线程数、最大线程数、队列长度等参数，以适应不同的场景





## 具体实现方式

一、JAVA内置线程池

• newFixedThreadPool：创建固定大小的线程池。

• newCachedThreadPool：创建一个可缓存的线程池，线程数量不固定，会根据需要创建新线程或复用已有线程。

• newSingleThreadExecutor：创建一个单线程的线程池，所有任务按顺序在一个线程中执行。

• newScheduledThreadPool：创建一个支持定时和周期性任务执行的线程池。



二、自定义线程池

通过 ThreadPoolExecutor 类的构造函数自定义线程池的参数，实现更灵活的线程池配置。

```java
```

## 实战案例

### IO密集型



### CPU密集型
