# im思考

Here's the table of contents:

1. TOC
{:toc}

## 使用场景

im作为即时通讯方式，能够让我们快速收发消息。不仅如此，日常使用的通讯类APP、社交类APP、购物APP等，IM也都是重要的功能模块。

IM系统中最核心的是消息系统，而消息系统的核心功能是消息的同步、存储和检索：

- 消息同步：将消息完整、快速地从发送方传递到接收方。最重要的衡量指标就是消息传递的实时性、完整性以及能支撑的消息规模。消息的在线和离线推送属于基础功能，消息的多端同步属于高级功能。
- 消息存储：消息的持久化保存。现代消息系统要求能支持消息在服务端的在线存储，从而实现账号在任意端登录查看所有历史消息
- 消息检索：消息一般是文本，消息被在线存储后就要求能被实时检索到

## 基础模型

消息系统有很多不同的实现方式，主要差异在消息同步和存储的方案，共性其实类似，主要有三种方式：读扩散、写扩散、混合模式。同步和存储可以使用其中一种方式来实现。

### 读扩散

也称拉取模型，每个人/群对应一个会话，消息只要写一次，但是用户需要从所有的会话中拉取消息。如下所示：

![](http://minhy.top/image/im-%E8%AF%BB%E6%89%A9%E6%95%A3%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%9E%8B.drawio.png)

读扩散模型中，所有的群成员共享同一个信箱（群消息存储）；当产生一条群消息时，只需要将一条群消息投递（写入）到信箱中；所有群成员从这个信箱中读取群消息。

存在一些消息的定制化处理场景。例如：成员 A 删除了一条群消息，不能影响其他群成员浏览这条群消息。一般会专门设计一张 “群消息删除表” 来记录删除的群消息id，每个群成员从信箱中读取群消息后，再读取 “群消息删除表”，以此判断该群消息是否展示。不仅仅是删除场景，同样适用于其他附加业务。

- 优点：消息的写入逻辑简单（只写一条记录即可），消息存储成本较低，写入实时性好，没有时延问题。
- 缺点：数据的读取逻辑复杂，不仅要读取消息存储表，还要读取其他业务表后进行数据聚合；潜在问题是多用户并发读取时会形成 IO 的热点，造成性能急剧下降。

读扩散模型通常应用在群成员数量很高，读少写多的业务场景中。

### 写扩散
也称推送模型，所有人对应一个会话信箱，消息都写入到一个信箱中。在群聊场景下会被放大。

具体流程如下所示：

![](http://minhy.top/image/im-%E5%86%99%E6%89%A9%E6%95%A3%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%9E%8B.drawio.png)

每一个群成员都有自己独立的 “信箱”；产生一条群消息时，需要分别投递（写入）到每个成员的信箱中；每个成员对群消息进行读取时，只需要从自己的信箱中拉取消息。

- 优点：读取逻辑简单，大量用户高并发读取时，避免了锁操作，有较大的性能优势；存储隔离，方便消息定制化处理。

- 缺点：消息存储成本很大，发送消息操作较为耗时。

群聊中一个成员发送消息后，其他成员都会存一条记录。适用于成员数量不多，读多写少的场景

### 读写扩散

读写扩散模型，在im场景、Feed流（朋友圈、微博等）等许多场景都有使用。

模型中有`订阅`,`发布`,`取消订阅`等业务动作。

一、订阅

以微博为例，`a`,`b`,`c`三个用户，a是bc的粉丝，b是c的粉丝，关注和被关注的关系如下所示：

![](http://minhy.top/image/im-%E7%B2%89%E4%B8%9D%E6%A8%A1%E5%9E%8B.drawio.png)

关注列表、被关注列表分别存储，可以使用redis k-v存储+mysql持久化

二、发布

用户c发布了两条消息，msg1 msg2，不同模型中的存储方式不同：

- 写扩散：msg1 msg2两条消息都会在ab的收件箱中存储，ab收取消息时分别从各自的收件箱中获取消息即可
- 读扩散：msg1 msg2只写入c的发件箱，a收取消息时首先从关注列表中得到要拉取的对象，再获取对象的消息

## 现代消息架构

消息先存储后同步。如果接收方确认收到了消息，那这条消息一定已经在云端保存了。

消息会有两个库来保存：1.消息存储库，用于全量保存所有会话的消息，主要用于支持消息漫游；2.消息同步库，主要用于接收方的多端同步。

消息从发送方发出后，经过服务端转发，服务端会先将消息保存到消息存储库，然后保存到消息同步库。

消息持久化后，对于在线的接收方，会直接在线推送，这是较优的消息传递方式，但不是必须的。对于在线推送失败或者离线的接收方，会有另一个统一的消息同步方式。接收方会主动向服务端拉取所有未同步消息，但接收方何时何地（端类型）发起消息同步对服务端来说未知，所以服务端必须保存所有需要同步到接收方的消息，这通过消息同步库实现。

对于新的同步设备，会有消息漫游需求，这通过消息存储库实现，在消息存储库中，可以拉取任意会话的全量历史消息。

消息检索的实现依赖于对消息存储库内消息的索引，通常是一个近实时（NRT，near real time）的索引构建过程，这个索引同样是在线的。
