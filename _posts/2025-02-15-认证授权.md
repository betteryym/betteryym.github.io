# 认证授权

## 前言
HTTP/HTTPS都是无状态协议，意味着它们本身不会保留与服务器之间的会话信息，即每次请求都是独立的。

日常生活中我们可能登录某个网站后，隔天还是保持登录状态，既然HTTP是无状态的，那浏览器是如何保存登录信息的呢？这就涉及到状态管理。

客户端的状态管理包括认证与授权：认证，系统识别当前用户的身份；授权，系统判断当前用户应该具有的权限。

## 认证方式

### **cookie和session**

cookies是网站存放在客户端中的文本文件，用来保存用户信息。一般有以下功能：

1. 会话管理：记录用户的登录状态、购物车内容等
2. 个性化：存储用户的偏好设置
3. 跟踪与分析：记录和分析用户行为，用于广告投放

在使用浏览器请求服务端时，服务端会根据行为让浏览器设置cookie，后续每次请求都会带上cookie。

![](http://minhy.top/image/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83-cookie%E6%B5%81%E7%A8%8B.drawio.png)

服务端通过读取cookie，能够了解到客户端的状态，这是状态管理的关键。

同一个域名下，浏览器会自动在请求中携带cookie去调用服务器。需要注意cookie会有CSRF风险。对于跨域请求，需要额外配置。

session存放在服务端，通过服务端记录用户的状态。将session内容保存在服务端（redis），sessionid写入cookie中。请求时能够通过cookie中的session_id获取到信息。session中的信息可以更为丰富。

![](http://minhy.top/image/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83-session.drawio.png)

**多服务器节点**

- 同一个用户的所有请求通过特定的hash策略分配给同一个服务器处理（受到服务器宕机、漂移、重启、部署的影响）
- session数据服务器间同步
- 使用单独的数据节点
- redis等外部缓存

**局限性**

使用 **Session 机制**在移动端中有很多局限性。Session 认证设置cookie后，依赖浏览器自动携带。 Cookie 强依赖于浏览器环境，而移动端往往不具备传统浏览器的完整特性。

移动端不能自动管理 Cookie，并且每个用户的 Session 数据存储在服务端，用户量庞大时，服务端存储和查询压力剧增。Session 依赖 Cookie 传递 Session ID，需额外防御 CSRF（如添加 CSRF Token），而移动端缺乏浏览器自动处理 CSRF Token 的能力。

Token（如 JWT）自包含用户信息，无需服务端维护会话状态，更适合移动端网络环境。Token无需服务端存储，用户身份信息直接嵌入 Token 中，服务端只需验证签名即可，适合高并发场景。Token 通常通过 `Authorization` 请求头传递，不受跨域限制，且不依赖 Cookie，天然避免 CSRF 攻击。

移动端若通过不安全方式存储 Cookie（如明文 SharedPreferences），可能被恶意应用窃取。token 可存储在安全的系统级存储（如 iOS Keychain、Android Keystore），甚至仅在内存中，降低泄露风险。
### **token**

服务端生成，客户端存储，通常保存在localStorage/内存中。客户端在请求中需要手动将token添加在请求头中，服务端收到请求后进行验证。容易受到XSS攻击，支持跨域。

在移动端，**Token 认证（如 JWT、OAuth2）** 是更优选择：
- **无状态**：服务端无需存储会话数据。
- **标准化传递**：通过 `Authorization` 头传递，跨平台一致。
- **自包含信息**：Token 可嵌入用户身份、权限和有效期。
- **安全性**：避免 CSRF，支持灵活存储策略（如内存+短期有效期）。

通过 Token 机制，移动端能更好地适配网络环境、设备多样性和高并发需求，同时简化架构设计。

#### **JWT**

JWT（JSON Web Token）是一种基于Token的认证授权机制，适用于跨域认证，是一种规范化的JSON结构Token。包含了身份验证所需要的所有信息，是无状态的。可以有效避免CSRF攻击，因为JWT一般存在localStorage中，身份验证过程不会涉及到Cookie。

JWT本质上是一个字符串，通过`.`划分成三个Base64Url 编码的部分：
- Header，头部：元数据，定义了生成签名的算法以及Token类型。
- Payload，载荷：存放实际需要传递的数据，包含声明Claims, 主题Sub，JWT ID
- Signature，签名：服务器通过payload, header和密钥secret，使用header里指定的签名算法生成。

示意结构：`aaa.bbb.ccc`，可以参考https://jwt.io/

**Header**通常由两部分组成：

1. typ, type: 令牌类型，JWT
2. alg, algorithm：签名算法
```json
{
	"alg": "HS256",
	"typ": "JWT"
}
```

Payload,包含了声明Claims，默认不加密。Claims分三种类型：and

1. 注册声明，Registered Claims：预定义的一些声明，建议使用，非强制性
2. 公有声明，public Claims：JWT签发方可以自定义的声明，
3. 私有声明，private Claims：因为项目需要而自定义的声明
以下是一些常见的注册声明：
1. iss, issuer: JWT 签发方
2. iat, issued at time: 签发时间
3. sub, subject：主题
4. aud, audience: 接收方
5. exp， expiration time: 过期事件
6. nbf，not before time：生效时间
7. jti, JWT ID:唯一标识

**signature**

对前两部分的签名，防止JWT数据被篡改。签名的生成方式：将 `Header + payload + 服务端密钥`组成的字符串使用签名算法进行加密得到。

计算公式：

```text
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  your-256-bit-secret
) secret base64 encoded
```
**验证过程**

![](http://minhy.top/image/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83-JWT.drawio.png)

最重要的是使用服务端的secret加盐，与信息一起加密，校验阶段会重新生成一份signature、与JWT中的那份进行对比，根据对比结果判断信息是否被更改。

#### 过期

使用cookie-session机制，在服务端删除session信息，就能实现登录状态过期。Token本身是无状态的，怎么实现状态过期？

针对手动注销/退出登录场景，使用白名单/黑名单方式：

- 白名单：将token存在服务端redis，请求时校验Token是否存在，存在则走后续流程
- 黑名单：将token存在服务端redis，请求时校验Token是否存在，不存在则继续

存储token的形式有点违背token的无状态，但为了登录过期，也是常用的方法。

另一种方法是将过期时间信息放在token里，这只能实现定期更换，有效期是一定的。

token存在续签问题，即当前token过期了应该怎么认证，是否需要重新登录？

重新登录是最简单的方式，如果token的有效期较短，用户体验会较差。日常使用的场景一般是，很长时间没有登录APP才需要重新登录，频繁登录使用APP就不需要重新登录。针对这种场景，服务端内部应该完成token的自动续签。

1. 服务端发现token快过期了，重新生成，需要客户端配合检查新旧token是否一致
2. 服务端每次都返回新的token，开销较大、不推荐
3. 存储两个token（一个验证token、一个续签token，续签token的有效期较长）

## 网络安全

### CSRF

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

一个典型的CSRF攻击有着如下的流程：

1. 受害者登录a.com，并保留了登录凭证（Cookie）。
2. 攻击者引诱受害者访问了b.com。
3. b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。
4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
5. a.com以受害者的名义执行了act=xx。
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

**常见类型：**

1. GET请求：例如把链接放在图片链接里，用户访问图片链接就会发起一次跨域请求；
2. POST类型：利用自动提交的表单，模拟用户完成一次POST操作
3. 链接类型：在论坛/广告中嵌入恶意链接，诱导用户点击，携带恶意代码访问网站

**特点：**

- 攻击一般发起在第三方网站，而不是被攻击网站。被攻击网站无法防止攻击发生。
- 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
- 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，这种攻击更危险。

**防护策略**

CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。CSRF的两个特点：

- CSRF（通常）发生在第三方域名。
- CSRF攻击者不能获取到Cookie等信息，只是使用。

针对这两点，我们可以专门制定防护策略，如下：

- 阻止不明外域的访问
    - 同源检测
- 提交时要求附加本域才能获取的信息
    - CSRF Token
    - 双重Cookie验证

**同源检测**

Header中的Origin，Referer字段在浏览器发起请求时大多数情况下会自动带上，而且不能由前端自定义内容。可以通过解析这两个Header中的域名，确定请求的来源，如果没有携带这两个字段，就直接阻止。

这只能判断出是否外域请求，但如果网站本身就会放在第三方页面上（例如百度搜索），就没办法防御CSRF攻击了，需要做额外的防护措施。

**Token防御**

1. 用户访问页面的时候，服务器给用户生成一个Token，该Token通过加密算法对数据进行加密（一般包含随机字符串和时间戳的组合），提交时不再放在cookie中（会自动提交）
2. 下次访问时请求携带Token
3. 服务器验证Token是否争取
生成方式不同，验证方式也会有差异。
1. 完全随机生成，需要将token的内容在服务端保存，一般存在Redis之类的公共存储空间，读取和验证的压力都较大
2. 通过计算生成Token，例如UserId+时间戳+随机数的组合加密生成Token，验证前先进行解密，再校验Token有效性

**双重Cookie校验**

在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。

那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。

双重Cookie采用以下流程：

- 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如`csrfcookie=v8g9e4ksfhw`）。
- 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例`POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw`）。
- 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。

此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。

这种方法如果针对大型网站（含有多个子域名），某个子域名遭受攻击，会影响到整体的安全性，因此没有大规模应用。
### XSS

XSS是跨站脚本攻击(Cross Site Scripting)。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。

**反射型XSS**

攻击相对于访问者而言是一次性的，恶意脚本通过url的方式传递给了服务器，而服务器则不加处理的把脚本“反射”回访问者的浏览器、而使访问者的浏览器执行相应的脚本。想要触发漏洞，需要访问特定的链接才能够实现。

**储存型XSS**

它与反射型XSS最大的不同就是服务器在接收到恶意脚本时会将其做一些处理。

例如储存到数据库中，当再次访问相同页面时，将恶意脚本从数据库中取出并返回给浏览器执行。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。

这个过程一般而言只要用户访问这个界面就行了，不像反射型XSS，需要访问特定的URL。

**实际应用**

1. 劫持访问：在恶意脚本中插入代码（页面会跳转到指定首页）
2. 盗用cookie实现无密码登录
3. 配合CSRF攻击完成恶意请求：例如修改用户密码

防范手段：
- 过滤。对诸如\<script\>、\<img\>、\<a\>等标签进行过滤。
- 编码。像一些常见的符号，如<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。  
- 限制。xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。
