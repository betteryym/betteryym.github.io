# 补偿赠券算法联想

作为程序员，很难避开数据结构和算法的学习，这是一个痛苦且漫长的过程。

而在工作过程中，又难免会产生这种想法：数据结构和算法对工程实践的作用体现在哪？可能大多数人都会回答：数据结构和算法对面试十分重要。但实际上，数据结构和算法对编程思想、工程思想是潜移默化的。

之前业务上有一个场景：用户投诉平台索要赔偿，平台采用赠送优惠券的形式进行补偿，赔偿的金额是一个有零有整的数字，但是优惠券的面额枚举是有限的（例如：1元、3元、5元、10元、20元、50元...）。问题来了，应该给用户补偿几张优惠券呢，优惠券组合的计算方式又是怎么样的呢？

（优化前线上的补偿方式一言难尽）

一、优惠券金额最接近但不大于补偿金额、优惠券数量尽可能少

```c++
#include<iostream>
#include <algorithm>
using namespace std;

vector<int> getCouponCombination(int total, vector<int>& couponList){
    vector<int> res;
    sort(couponList.begin(), couponList.end());
    int i = couponList.size() - 1;
    while(total > 0 && i >= 0){
        while(total >= couponList[i]){
            res.push_back(couponList[i]);
            total -= couponList[i];
        }
        i--;
    }
    return res;
}

int main(){
    vector<int> couponList = {2, 5, 10, 20, 30, 50, 80, 100};
    vector<int> res = getCouponCombination(23, couponList);
    for(int num: res){
        cout << num << ",";
    }
    return 0;
}
```

基本思路：

1. 将优惠券从小到大排序
2. 贪心补偿不大于需补金额下面额最大的券
3. 当面额最小的券也比需要补偿的金额大时，终止补偿

二、优惠券金额最接近但不大于补偿金额，优惠券数量尽量不要太大

可能使用的场景：希望用户多用几次优惠券，但是面额不能太小。

核心思想仍然是贪心获取优惠券。

在这个基础上增加阶梯补偿机制，即不同区间下的补偿金额可选的优惠券数量是不同的，例如：

- 0-50下优惠券组合范围：2, 5, 10, 20
- 50-100下优惠券组合范围：2, 5, 10, 20, 30, 50
- ...

在上文的算法基础上，根据实际的补偿金额找到可选的优惠券范围，再复用前文的算法即可。

而根据实际补偿金额找到可选的优惠券范围，可以使用二分法（针对区间较大的情况），如果组合范围数量较少，遍历即可。