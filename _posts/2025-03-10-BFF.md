# BFF

### 架构演变

#### 单体架构

所有功能都部署在一起，使用同一个数据库。

优点在于开发、部署、联调成本低。

缺点在于各个业务代码耦合、维护困难，其中某个业务流量大的话，不能针对性优化，只能整个服务集群机器数量增加，并发能力较差。

#### 业务垂直拆分

将服务按照功能维度进行拆分，但是拆分的粒度仍然较粗。

优点在于实现了流量拆分，各个服务可以单独扩容，容错率增加。

缺点在于各个系统之间相对独立，底层存在很多共同需要的能力，但是各自重复开发了，效率较低。

#### 分布式服务

对后端服务区分基础模块和业务模块，由基础模块提供公有的能力，例如鉴权、缓存等能力，业务模块只需要聚焦自己的业务逻辑，通用的基础能力去调用基础模块即可。

#### SOA架构

SOA的设计方法在于将一个大的业务功能打包对外提供，整个业务功能中包含多个服务、各服务互相独立，能够灵活调整、互相通信。

SOA中，通常是一个大型的服务负责多个业务功能，这些业务可能会共用一个数据库。服务之间通信使用特定的通信协议进行通信（如SOAP），由一个集中的企业服务总线ESB进行协调、处理消息路由、事务管理等功能。

#### 微服务架构

通常每个服务只做一件事，各个服务数据库互相独立，服务间使用HTTP、gRPC通信，可以独立部署和水平扩展。类似面向对象开发的思想，服务之间的业务尽量减少耦合。

使用更加动态的服务发现机制进行服务协调

### API网关

从互联网发展的历史和现状，可以看出微服务架构流行的原因。服务之间职责划分清晰、需要具备单独水平扩展的能力，复杂业务场景下，能够快速平稳迭代。

对于一个大型业务，后端通常会有很多个微服务。客户端应用程序可以直接向某些微服务发出请求，通过域名或者IP端口访问。这种模式下有很多问题：

- 一个页面可能需要来自多个后端服务的数据，由端上发起多个请求、同时与多个微服务通信，会增加网络上的数据往返次数，可能导致高延迟和高复杂度
- 每个微服务可能存在一些共性的功能，例如认证、授权、限流等等操作，如果每个微服务都要去实现一套逻辑，会带来巨大的重复开发量。
- 一些具体的业务场景，例如针对某个功能进行灰度实验，同一套逻辑可能需要在多个服务端维护，带来一些不确定性和风险，因为需要多个服务方去共同维护这些配置，导致后续维护困难

因此产生了API网关，端上的请求先打到api网关，由API网关做一些横切的功能， 认证、授权、限流等等功能都可以在API网关层实现，从而解决一些跟业务无关的逻辑。

互联网发展早期，只有浏览器/客户端调用服务，通常两者没有交集，架构大概如下：

![](http://minhy.top/image/BFF-v1.drawio.png)

通常一个API网关根据需要可能会具备这些功能，也支持动态配置：

- 认证和授权
- 服务发现
- 响应缓存
- 重试策略
- 限流
- 负载均衡
- 灰度发布
- 协议转换

### BFF

随着移动APP盛行，同一个服务可能会接受来自多种端的请求。

![](http://minhy.top/image/BFF-v2.drawio.png)

移动APP，也有端类型的差异，例如安卓和IOS差异。每种类型的端可能会接收不同的数据，要么返回更多的数据，让端上自己适配，或者每种类型的端对应不同的接口。前后端因为端类型的差异，多了很多冗余逻辑。

于是BFF架构应运而生，前后端之间增加了一层BFF，BFF的主要工作内容：端上某个页面可能需要后端多个服务的数据，前端只需要请求BFF，由BFF并发去请求后端多个服务、将响应聚合、并根据需要增加一些样式数据（文案、图片等等）。

BFF隔离了前端UI展示对后端API的需求，后端可以专注自己的核心业务能力。而BFF也能根据已有的后端API，快速满足前端UI展示的需求。

![](http://minhy.top/image/BFF-v3.drawio.png)

通过在前后端之间增加一层BFF，能够实现解耦，增加一层也是其他场景解耦的通用手段。

以上展示了单一BFF的场景，移动端、web端共用一个BFF，同样会导致代码编写复杂度增加，可能需要对端类型进行适配，同一个需求，可能要开发多套响应数据。

![](http://minhy.top/image/BFF-v4.drawio.png)



每种业务或者每种客户端采用自己独立的BFF层，这样每种客户端的服务更加灵活，不同的BFF端对于展示服务解耦性更高。

为每一个端都提供一个对应的 **`BFF`**，每个端的**`BFF`**处理自身的业务逻辑，需要数据时从**`基础服务`**内获取，然后在接口返回之前进行组装数据用于实例化返回对象。

与此同时，BFF层可能也会承担网关的职责。

#### 详情介绍

BFF，Backend of Front，是近些年衍生出的一种开发模式，为了适配微服务模式下钱后端接口调用混乱而出现的。如今微服务系统盛行，通常一个大型系统内会划分出数十个服务模块，例如订单、仓储、物流、搜索、推荐、用户等等系统，前端也有小程序、APP、网页等等。

痛点

1. 前端每次需求开发都要对接多个系统来确定接口信息，接口繁多，开发调试效率低下
2. 后端需要各自包装数据信息供前端处理，需要根据不同版本、客户端、用户、定位等特征来判断，在展示方面浪费了时间，不同专注于业务逻辑，而且后端系统规则不同意，历史版本多、耦合严重
3. 产品需求变更时，微小的改动都需要多个系统联调、测试、上线
https://blog.csdn.net/wan212000/article/details/131708082

因此需要一个中间层来适配前后端服务，就产生了BFF，负责将所有后端接口进行收口，下游提供RPC接口给网关使用，BFF网关提供WEB接口给前端调用，最后将数据进行组装拼接，根据前端的需求返回数据。

网关特点

一、内容繁杂
BFF主要为前端服务，前端不关心版本、客户端、定位、用户身份等情况，只接收数据即可，这些逻辑都需要耦合到BFF网关中，以版本、客户端、定位、用户等特征作为维度，其中版本是最复杂的，系统开发过程中可能会有几十个版本，因此需要对不同版本做兼容，根据各种条件组合生成唯一的数据，最终返回给端。

二、数据琐碎
BFF是无状态的，不需要数据库，所以有很多数据需要以静态变量的形式存放在代码里，或者是使用配置中心来动态配置，例如图片地址、颜色、文案、icon等等，这些数据都会存放在BFF网关中维护，如果放在客户端中，修改需要发版、周期过长，如果放在后端，会额外增加很多与业务无关的样式逻辑，而且后端服务较多，很难在同一个地方进行管理。

三、逻辑琐碎
BFF聚合了下游接口，每次流程需要调用几十个后端接口，根据历史版本、端类型、用户进行逻辑判断，历史逻辑与新需求杂糅，实现新功能的同时要不断兼顾历史逻辑，因此会加入大量的分支判断，这可以通过设计模式进行优化，但是众多逻辑仍然保留在BFF

性能
网关耗时主要有两部分：
1. 内部处理耗时
2. 下游RPC接口耗时
BFF与端上直接交互，因此接口耗时会直接影响用户浏览体验，所以一定要保证性能良好，压缩耗时来提高接口响应速度。
可以使用编排框架将下游接口调用进行优化，然后使用线程池进行并发处理，从而降低下游接口耗时

缓存

不要在BFF中使用缓存中间件
因为BFF主要数据来源都是通过RPC接口调用获取，这是耗时的关键点，想要耗时减少，应该使用并发/编排能力，不可以通过缓存下游接口数据实现。

- 成本问题：面向C端的接口，用户量大，首先缓存命中概率很小，如果真的需要缓存，那缓存数据量很大，造成严重的缓存空间浪费
- 一致性问题：如果BFF有缓存，会进一步增加问题排查难度

降级

任何时候都不要将错误直接返回给用户，不管是下游错误还是系统错误。降级可以分为两种类型：

- 下游接口降级：下游接口耗时/数据异常时，需要做好降级措施，例如增加接口超时时间判断，及时中断调用，不能因为某个下游接口而影响整体性能，下游接口报错时，做好异常捕获，可以不展示这部分数据、或增加兜底展示
- 异常整体降级：网关层、后端层都不可避免会有问题，需要做整体降级，例如增加兜底展示、给用户引导页，整体降级尽量收口在BFF

接口粒度

BFF下游接口较多，建议是按照页面来划分, 例如在首页可以提供首页接口返回整体展示效果, 购物车页面提供购物车接口, 以页面为单位划分可以方便前后端的统一处理, 当然如果页面内容太多时, BFF 网关接口可能耗时较多, 可以同页面拆分开来, 让前端并行加载接口, 这样既能降低整体页面加载时间, 也能让 BFF 网关减少下游接口调用。

数据安全

BFF 网关虽然也叫网关, 但数据安全方面例如安全攻防等主要还是外层去做, BFF 只负责数据的调用组装, 不要再赋予其他太多功能, 但 BFF 网关一定要有限流逻辑, 可以采用 Sentinel 等框架实现, 防止某个前端异常进行大量请求, 打垮 BFF 网关导致所有前端异常。

上线注意事项

BFF 网关较为单薄, 没有依赖的数据库等大型中间件, 可能只是用到比较轻量的配置中心和消息队列, 所以上线时初始化参数较少, 但因为 BFF 网关需要做版本、定位、客户端等特征的数据处理, 所以一定要做好灰度上线, 防止新功能影响到历史版本、不同定位下的用户浏览。

优点

降低后端开发联调成本: 直接提供 RPC 接口将基础数据返回即可

降低前端开发联调成本: 直接对接一两个接口就可以拿到全部数据, 并且可以将很多前端写死的逻辑交给 BFF 网关做下发, 提高前端展示的灵活性。

方便需求迭代升级: 当大量前端逻辑移植到 BFF 网关, 很多需求的上线不再依赖前后端发版, 直接让 BFF 快速上线更新即可。

提高用户体验: BFF 网关可以较低成本的做异常降级处理, 为前后端包装错误提示, 统一异常捕获类型。

提高系统性能: 虽然引入 BFF 网关相当于多加了一层, 但 BFF 网关可以通过并发调用下游接口, 或者线程池的形式提高接口处理性能, 而不需要像之前前端去逐个调用接口, 规范了整体接口调用执行逻辑。
