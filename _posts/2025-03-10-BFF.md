# BFF

### 架构演变

#### 单体架构

所有功能都部署在一起，使用同一个数据库。

优点：开发、部署、联调成本低。

缺点：各个业务代码耦合、维护困难，不能针对性优化单独某个大流量业务，只能整个服务集群机器数量增加，并发能力较差。

#### 业务垂直拆分

将服务按照功能维度进行拆分，但是拆分的粒度仍然较粗。

优点：实现了流量拆分，各个服务可以单独扩容，容错率增加。

缺点：各个系统之间相对独立，底层存在很多共同需要的能力，但是各自重复开发了，效率较低。

#### 分布式服务

对后端服务区分基础模块和业务模块，由基础模块提供公有的能力，例如鉴权、缓存等能力，业务模块只需要聚焦自己的业务逻辑，通用的基础能力去调用基础模块即可。

#### SOA架构

SOA的设计方法在于将一个大的业务功能打包对外提供，整个业务功能中包含多个服务、各服务互相独立，能够灵活调整、互相通信。

SOA中，通常是一个大型的服务负责多个业务功能，这些业务可能会共用一个数据库。服务之间通信使用特定的通信协议进行通信（如SOAP），由一个集中的企业服务总线ESB进行协调、处理消息路由、事务管理等功能。

#### 微服务架构

通常每个服务只做一件事，各个服务数据库互相独立，服务间使用HTTP、gRPC通信，可以独立部署和水平扩展。类似面向对象开发的思想，服务之间的业务尽量减少耦合。

使用更加动态的服务发现机制进行服务协调。

### API网关

从互联网发展的历史和现状，可以看出微服务架构流行的原因。服务之间职责划分清晰、需要具备单独水平扩展的能力，复杂业务场景下，能够快速平稳迭代。

对于一个大型业务，后端通常会有很多个微服务。客户端应用程序可以直接向某些微服务发出请求，通过域名或者IP端口访问。这种模式下有很多问题：

- 一个页面可能需要来自多个后端服务的数据，由端上发起多个请求、同时与多个微服务通信，会增加网络上的数据往返次数，可能导致高延迟和高复杂度
- 每个微服务可能存在一些共性的功能，例如认证、授权、限流等等操作，如果每个微服务都要去实现一套逻辑，会带来巨大的重复开发量。
- 一些具体的业务场景，例如针对某个功能进行灰度实验，同一套逻辑可能需要在多个服务端维护，带来一些不确定性和风险，因为需要多个服务方去共同维护这些配置，导致后续维护困难
- 前端每次需求开发都要对接多个系统来确定接口信息，接口繁多，开发调试效率低下
- 产品需求变更时，微小的改动都需要多个系统联调、测试、上线

因此产生了API网关，端上的请求先打到api网关，由API网关做一些横切的功能， 例如认证、授权、限流等等功能都可以在API网关层实现，从而解决一些跟业务无关的逻辑。

互联网发展早期，只有浏览器/客户端调用服务，通常两者没有交集，架构大概如下：

![](http://minhy.top/image/BFF-v1.drawio.png)

通常一个API网关根据需要可能会具备这些功能，也支持动态配置：

- 认证和授权
- 服务发现
- 响应缓存
- 重试策略
- 限流
- 负载均衡
- 灰度发布
- 协议转换

### BFF

#### 现状

随着移动APP盛行，同一个服务可能会接受来自多种端的请求。

![](http://minhy.top/image/BFF-v2.drawio.png)

移动APP，也有端类型的差异，例如安卓和IOS、小程序、网页等。每种类型的端可能会展示不同的内容、或者不同的样式，这种情况下有几种解决方案：1. 返回更多的数据，让端上自己适配； 2.每种类型的端对应不同的接口。

前后端因为端类型的差异，多了很多冗余逻辑。后端需要各自包装数据信息供前端处理，需要根据不同版本、客户端、用户、定位等特征来判断，在展示方面浪费了时间，不能专注于业务逻辑，而且后端系统规则不统一，历史版本多、耦合严重。

于是BFF（Backend of Front）架构应运而生，前后端之间增加了一层BFF，BFF的主要工作内容：端上某个页面可能需要后端多个服务的数据，前端只需要请求BFF，由BFF并发去请求后端多个服务、将响应聚合、并根据需要增加一些样式数据（文案、图片等等）。BFF负责将所有后端接口进行收口，下游提供RPC接口给网关使用，BFF网关提供WEB接口给前端调用，最后将数据进行组装拼接，根据前端的需求返回数据。

BFF隔离了前端UI展示对后端API的需求，后端可以专注自己的核心业务能力。而BFF也能根据已有的后端API，快速满足前端UI展示的需求。

![](http://minhy.top/image/BFF-v3.drawio.png)

通过在前后端之间增加一层BFF，能够实现解耦，增加一层也是其他场景解耦的通用手段。

以上展示了单一BFF的场景，移动端、web端共用一个BFF，同样会导致代码编写复杂度增加，可能需要对端类型进行适配，同一个需求，可能要开发多套响应数据。

![](http://minhy.top/image/BFF-v4.drawio.png)

每种业务或者每种客户端采用自己独立的BFF层，这样每种客户端的服务更加灵活，不同的BFF端对于展示服务解耦性更高。

为每一个端都提供一个对应的 **`BFF`**，每个端的**`BFF`**处理自身的业务逻辑，需要数据时从**`基础服务`**内获取，然后在接口返回之前进行组装数据用于实例化返回对象。

与此同时，BFF层可能也会承担网关的职责。

**优点**

1. 降低后端开发联调成本: 直接提供 RPC 接口将基础数据返回给BFF，专注业务逻辑
2. 降低前端开发联调成本: 只需要对接BFF就可以拿到全部数据, 可以将很多前端写死的逻辑交给 BFF 网关下发, 提高前端展示的灵活性。
3. 方便需求迭代升级: 当大量前端逻辑移植到 BFF 网关, 样式更改不再依赖前后端发版, 直接让 BFF 快速上线更新即可。
4. 提高用户体验: BFF 网关可以较低成本的做异常降级处理, 为前后端包装错误提示, 统一异常捕获类型。
5. 提高系统性能: 引入 BFF 网关相当于多加了一层, 但 BFF 网关可以通过并发调用下游接口, 或者线程池的形式提高接口处理性能, 而不需要前端逐个调用接口, 规范了整体接口调用执行逻辑。

#### 特点

一、内容繁杂

BFF主要为前端服务，前端不关心版本、客户端、定位、用户身份等情况，只需要接收数据，这些逻辑会耦合到BFF网关中，以版本、客户端、定位、用户、端类型等特征作为参数条件，根据各种条件组合生成唯一的数据，最终返回给端。系统开发过程中可能会有几十个版本，BFF需要对不同版本做兼容，带来很多复杂适配逻辑。

二、数据琐碎

BFF是无状态的，不需要数据库，很多数据都需要以静态变量的形式存放在代码里，或者是使用配置中心来动态配置，例如图片地址、颜色、文案、icon等等，这些数据由BFF网关维护。如果放在客户端中，修改需要发版、周期过长，如果放在后端，会额外增加很多与业务无关的样式逻辑，而且后端服务较多，很难在同一个地方进行管理。

三、逻辑琐碎

BFF聚合了下游接口，前端每次请求需要调用几十个后端接口，根据历史版本、端类型、用户进行逻辑判断，历史逻辑与新需求杂糅，实现新功能的同时要不断兼顾历史逻辑，因此会加入大量的分支判断。

#### 注意事项

**耗时**

网关作为服务端的入口，请求的耗时会直接影响用户体验，因此接口的高效十分重要。网关耗时主要有两部分：1.内部处理耗时（只能通过代码优化）；2.下游RPC接口耗时，使用编排框架将下游接口调用进行优化，使用线程池并发处理，降低下游接口耗时。

BFF下游接口较多，建议按照页面来划分, 例如在首页可以提供首页接口返回整体展示效果, 以页面为单位可以方便前后端统一处理。如果页面内容太多, BFF 网关接口可能耗时增多, 可以把页面拆成多个组件, 让前端并行加载接口, 这样能降低整体页面加载时间, 也能让 BFF 网关减少下游接口调用。

**缓存**

BFF的接口响应速度十分重要，但是不能在BFF中使用缓存中间件、直接返回数据。因为BFF主要数据源都是通过RPC接口调用获取，这是耗时的关键，应该使用并发/编排能力降低耗时，不可以通过缓存下游接口数据实现。面向C端的接口，用户量大，缓存命中概率小，如果在BFF缓存数据、数据量很大、缓存空间严重浪费。如果BFF有缓存，会进一步增加问题排查难度。

**限流和降级**

数据安全方面例如安全攻防等主要还是外层去做, BFF 只负责数据的调用组装, 最好不要再赋予其他太多功能, 但 BFF 网关一定要有限流逻辑, 可以采用 Sentinel 等框架实现, 防止某个前端异常进行大量请求, 打垮 BFF 网关。

并且任何时候都不要将错误直接返回给用户，不管是下游错误还是系统错误。降级可以分为两种类型：

- 下游接口降级：下游接口耗时/数据异常时，要做好降级措施，例如增加接口超时时间判断，及时中断调用，不能因为某个下游接口而影响整体性能，下游接口报错时，做好异常捕获，可以不展示这部分数据、或增加兜底展示
- 异常整体降级：网关层、后端层都不可避免会有问题，需要做整体降级，例如增加兜底展示、给用户引导页，整体降级尽量收口在BFF

**上线**

BFF 网关较为单薄, 不依赖数据库等大型中间件, 可能会用到配置中心和消息队列, 上线依赖项少。 但BFF 网关需要做版本、定位、客户端等特征的数据处理, 所以必须做好灰度上线, 防止新功能影响到历史版本的用户体验。

#### 未来发展
